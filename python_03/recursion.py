# recursion.py

def factorial(n: int) -> int:
    """
    Вычисляет факториал числа n рекурсивно.
    - Временная сложность: O(n)
    - Глубина рекурсии: O(n)
    """
    if n < 0:
        raise ValueError("Факториал не определен для отрицательных чисел")
    if n == 0 or n == 1:
        return 1  # Базовый случай
    return n * factorial(n - 1)  # Рекурсивный шаг


def fibonacci_naive(n: int) -> int:
    """
    Вычисляет n-е число Фибоначчи (наивная рекурсия).
    - Временная сложность: O(2^n) - экспоненциальная
    - Глубина рекурсии: O(n)
    """
    if n < 0:
        raise ValueError("Числа Фибоначчи не определены для отрицательных n")
    if n <= 1:
        return n  # Базовые случаи (F(0)=0, F(1)=1)
    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)  # Рекурсивный шаг


def power(a: float, n: int) -> float:
    """
    Быстрое возведение числа a в степень n рекурсивным методом.
    - Временная сложность: O(log n)
    - Глубина рекурсии: O(log n)
    """
    if n == 0:
        return 1  # Базовый случай: a^0 = 1
    if n < 0:
        return 1 / power(a, -n)  # Обработка отрицательной степени

    # Рекурсивные шаги
    if n % 2 == 0:
        # Если степень четная: a^n = (a*a)^(n/2)
        return power(a * a, n // 2)
    else:
        # Если степень нечетная: a^n = a * a^(n-1)
        return a * power(a, n - 1)
