# Лабораторная работа №3 — Рекурсия. Анализ сложности и оптимизация

---

## Задание

1.  **Реализовать классические рекурсивные алгоритмы:**
    * Вычисление факториала (`O(n)`).
    * Вычисление чисел Фибоначчи (наивный подход, `O(2^n)`).
    * Быстрое возведение в степень (`O(log n)`).

2.  **Оптимизировать алгоритм Фибоначчи с помощью мемоизации:**
    * Реализовать мемоизированную версию (`O(n)`).
    * Сравнить производительность наивного и мемоизированного подходов.

3.  **Решить практические задачи:**
    * Ханойские башни.
    * Рекурсивный обход файловой системы.

4.  **Визуализировать результаты:**
    * Построить график зависимости времени выполнения от `n` для двух версий алгоритма Фибоначчи.

5.  **Оформить отчёт**, код по PEP8, использовать git.

---

## Методика эксперимента

### Замеры

Для измерения времени выполнения использовался встроенный модуль Python **`timeit`**. Чтобы минимизировать случайные отклонения, каждый замер для быстрых операций (мемоизация) усреднялся по 100 прогонам.

### Тестируемые операции

* **`fibonacci_naive(n)` (`O(2^n)`)** vs **`fibonacci_memo(n)` (`O(n)`)**

Эксперимент проводился для диапазона `n` от 1 до 36 для наивного алгоритма и от 1 до 100 для алгоритма с мемоизацией.

### Характеристики ПК

* **CPU:** Intel Core i7-8700 @ 3.6GHz
* **RAM:** 32 GB DDR4
* **OS:** Windows 11
* **Python:** 3.11.9

---

## Разбор сложности

### 1. Факториал (`factorial`) → `O(n)`

```python
def factorial(n: int) -> int:
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

Анализ: Это классический пример линейной рекурсии. Для вычисления factorial(n) функция вызывает саму себя n раз, каждый раз уменьшая аргумент на 1, пока не достигнет базового случая (n=1). Количество рекурсивных вызовов прямо пропорционально значению n. Следовательно, и временная, и пространственная сложность (из-за стека вызовов) равна O(n).

### 2. Быстрое возведение в степень (power) → O(log n)

```python
def power(a: float, n: int) -> float:
    if n == 0:
        return 1
    if n % 2 == 0:
        return power(a * a, n // 2)
    else:
        return a * power(a, n - 1)
```

Анализ: Этот алгоритм использует подход "разделяй и властвуй". Ключевая оптимизация происходит на шаге для четных степеней: power(a * a, n // 2). Здесь мы уменьшаем задачу (степень n) в два раза за одну операцию. Даже если степень нечетная, на следующем шаге она станет четной, и произойдет деление пополам. Количество шагов, необходимых для того, чтобы свести n к 1 путем постоянного деления на 2, является логарифмом n по основанию 2. Поэтому сложность алгоритма — O(log n).

### 3. Наивные числа Фибоначчи (fibonacci_naive) → O(2^n)

```python
def fibonacci_naive(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)
```

Анализ: Это пример экспоненциальной сложности. Каждый вызов функции (кроме базовых) порождает два новых рекурсивных вызова, образуя дерево вызовов. Например, для fib(5) будет вызван fib(4) и fib(3). В свою очередь, fib(4) вызовет fib(3) и fib(2). Значение fib(3) вычисляется дважды с нуля. Чем больше n, тем больше таких повторных вычислений. Количество узлов в этом дереве растет экспоненциально, примерно как 2^n. Это делает алгоритм крайне неэффективным для n > 40.

### 4. Фибоначчи с мемоизацией (fibonacci_memo) → O(n)

```python
fib_cache = {}
def fibonacci_memo(n: int) -> int:
    if n in fib_cache:
        return fib_cache[n]
    if n <= 1:
        return n
    result = fibonacci_memo(n - 1) + fibonacci_memo(n - 2)
    fib_cache[n] = result
    return result
```

Анализ: Мемоизация — это техника кеширования результатов. При первом вызове fib_memo(k) для любого k результат вычисляется и сохраняется в fib_cache. Все последующие вызовы fib_memo(k) немедленно возвращают сохраненное значение за O(1).
В результате дерево вызовов "схлопывается". Каждое значение от fib(2) до fib(n) вычисляется ровно один раз. Общее количество вычислений становится пропорционально n, что снижает сложность с экспоненциальной O(2^n) до линейной O(n).

## Результаты

Основной фокус эксперимента — сравнение производительности наивного и мемоизированного алгоритмов Фибоначчи.

### Сравнение времени и количества вызовов для n=35

| Метрика | Наивная рекурсия O(2^n) | Рекурсия с мемоизацией O(n) |
|---|---:|---:|
| Время выполнения | ~1.8-3.0 секунды | ~0.000001 секунды |
| Кол-во вызовов | 29,860,703 | 69 |

## Анализ графика

График визуально подтверждает теоретический анализ сложности.

**Наивная рекурсия (O(2^n)) — красная линия**

На графике видно, что кривая для наивного алгоритма сначала растет медленно, но после n ≈ 25 уходит почти вертикально вверх. Это классическое экспоненциальное поведение. Каждый следующий шаг требует почти вдвое больше вычислений, чем предыдущий. Время выполнения растет так быстро, что вычисление F(40) заняло бы уже несколько минут.

**Рекурсия с мемоизацией (O(n)) — зеленая линия**

Кривая для мемоизированного алгоритма представляет собой практически прямую линию. Это идеальная демонстрация линейной сложности. Время выполнения растет прямо пропорционально n. Даже для n=100 вычисления происходят почти мгновенно.

![Графики](fibonacci_performance_comparison.png)