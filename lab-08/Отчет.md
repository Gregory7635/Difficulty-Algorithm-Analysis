# Лабораторная работа №8 — Жадные алгоритмы. Анализ сложности и визуализация

**Дата:** [2025-11-10]  
**Семестр:** [6 семестр]  
**Группа:** [ПИЖ-б-о-23-1]  
**Дисциплина:** [Анализ сложности алгоритмов]  
**Студент:** [Васильев Григорий Юрьевич]

---

## Реализация алгоритмов и анализ сложности

### 1. Дробный рюкзак (Fractional Knapsack) → O(n log n)

```python
def fractional_knapsack(values, weights, capacity):
    items = sorted(zip(values, weights), key=lambda x: x[0]/x[1], reverse=True)
    total_value = 0
    for value, weight in items:
        if capacity >= weight:
            total_value += value
            capacity -= weight
        else:
            total_value += value * (capacity / weight)
            break
    return total_value
```

**Анализ:**
- Основная операция — сортировка предметов по убыванию value/weight → O(n log n)
- Затем проход по массиву → O(n)
- Общая сложность: **O(n log n)**
- Пространственная сложность — **O(n)**

Жадность обоснована тем, что локальный выбор предмета с наибольшей "ценностью за единицу веса" приводит к глобальному оптимуму.

---

### 2. Задача о расписании интервалов (Interval Scheduling) → O(n log n)

```python
def interval_scheduling(intervals):
    intervals.sort(key=lambda x: x[1])
    result = []
    last_finish = -float('inf')
    for start, finish in intervals:
        if start >= last_finish:
            result.append((start, finish))
            last_finish = finish
    return result
```

**Анализ:**
- Сортировка интервалов по времени окончания — O(n log n)
- Проход по списку — O(n)
- Общая сложность: **O(n log n)**

Жадный выбор: выбираем интервал, заканчивающийся раньше всех — оставляем максимум времени для следующих.

---

### 3. Код Хаффмана (Huffman Coding) → O(n log n)

```python
import heapq

def build_huffman_code(frequencies):
    heap = [(freq, char) for char, freq in frequencies.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        w1, left = heapq.heappop(heap)
        w2, right = heapq.heappop(heap)
        heapq.heappush(heap, (w1 + w2, (left, right)))
    return heap[0][1]
```

**Анализ:**
- Каждое извлечение/вставка в кучу — O(log n)
- Для n элементов совершается n−1 объединение
- Общая сложность: **O(n log n)**
- Пространственная — **O(n)**

Жадность: объединяем два наименее вероятных символа — минимизируем среднюю длину кода (оптимальность по Шеннону).

---

### 4. Жадный алгоритм размена монет (Coin Change) → O(n)

```python
def greedy_coin_change(amount, coins):
    result = []
    for coin in coins:
        while amount >= coin:
            amount -= coin
            result.append(coin)
    return result
```

**Анализ:**
- Сортировка монет (если требуется) — O(n log n)
- Основная часть — линейный проход — O(n)
- Общая сложность: **O(n)**

Жадность: при стандартных наборах монет (1, 2, 5, 10, 50, 100) результат оптимален.  
Для произвольных номиналов оптимальность не гарантирована.

---

### 5. Минимальное остовное дерево (MST) — Алгоритм Краскала → O(E log E)

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return False
        if self.rank[ra] < self.rank[rb]:
            self.parent[ra] = rb
        else:
            self.parent[rb] = ra
            if self.rank[ra] == self.rank[rb]:
                self.rank[ra] += 1
        return True

def kruskal_mst(n_nodes, edges):
    uf = UnionFind(n_nodes)
    edges_sorted = sorted(edges, key=lambda x: x[2])
    mst, total = [], 0
    for u, v, w in edges_sorted:
        if uf.union(u, v):
            mst.append((u, v, w))
            total += w
        if len(mst) == n_nodes - 1:
            break
    return total, mst
```

**Анализ:**
- Сортировка рёбер — O(E log E)
- Операции find/union — амортизированное O(α(V))
- Общая сложность: **O(E log E)**
- Пространственная сложность: **O(V + E)**

Жадность: добавляем ребро с минимальным весом, не образуя циклов → глобальный оптимум.

---


### Условия эксперимента

* **CPU:** Intel Core i7-8700 @ 3.6GHz
* **RAM:** 32 GB DDR4
* **OS:** Windows 11
* **Python:** 3.11.9


## Результаты

| Алгоритм | Теоретическая сложность | Характер зависимости | Тип данных |
|-----------|------------------------|----------------------|------------|
| Fractional Knapsack | O(n log n) | Логарифмический рост | Множество предметов |
| Interval Scheduling | O(n log n) | Почти линейный | Список интервалов |
| Huffman Coding | O(n log n) | Логарифмический рост | Частоты символов |
| Coin Change | O(n) | Линейный рост | Номиналы монет |
| Kruskal MST | O(E log E) | Почти линейный | Граф (V, E) |

---

## Анализ графиков

**1. Huffman build time vs number of symbols**  
- Ось X — количество символов n (логарифмическая шкала)  
- Ось Y — время построения дерева  
- Кривая линейна в логарифмических координатах → подтверждает O(n log n)
![График](report/huffman_time.png)

**2. Coin Change — распределение выбранных монет**  
Для суммы 289 алгоритм выбрал:

```
100×2, 50×1, 20×1, 10×1, 5×1, 2×2
```

→ всего 8 монет (оптимально)
![График](report/coin_change.png)

**3. Kruskal MST**  
- Красные рёбра — минимальный остов  
- Суммарный вес = 14.0  
- Условия MST выполнены: V−1 рёбер, без циклов, связный граф.

---

![График](report/kruskal_mst.png)

## Контрольные вопросы

**1. Почему жадные алгоритмы не всегда дают оптимальное решение?**  
Локальный оптимум не гарантирует глобальный.  
Однако для задач Хаффмана, Краскала и Fractional Knapsack доказана оптимальность.

**2. Чем отличаются задачи, решаемые жадно, от тех, где нужно динамическое программирование?**  
В жадных алгоритмах оптимальное подрешение всегда входит в оптимум.  
В DP — подрешения могут конфликтовать (пример: 0/1 Knapsack).

**3. Почему сложность алгоритма Краскала O(E log E)?**  
Потому что сортировка рёбер — самая затратная часть.  
Операции union/find — почти константные.

**4. Как проверить корректность MST?**  
- Содержит V−1 рёбер  
- Без циклов  
- Граф связен  
- Суммарный вес минимален

**5. Почему алгоритм Хаффмана эффективнее равномерного кодирования?**  
Потому что частые символы получают короткие коды, редкие — длинные,  
что минимизирует среднее количество бит на символ.
