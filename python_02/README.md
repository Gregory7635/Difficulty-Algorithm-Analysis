# Лабораторная 02 — Основные структуры данных. Анализ и применение

---

## Задание

Реализовать класс `LinkedList` (односвязный список) с методами:

1.  `insert_at_start` (`O(1)`)
2.  `insert_at_end` (`O(1)` с `tail`)
3.  `delete_from_start` (`O(1)`)
4.  `traversal` (`O(n)`)

Сравнить производительность встроенных структур:

* `list.insert(0, x)` vs `LinkedList.insert_at_start`
* `list.append` vs `LinkedList.insert_at_end`
* `list.pop(0)` vs `deque.popleft`

Решить практические задачи:

* Проверка сбалансированности скобок (стек на `list`).
* Симуляция очереди печати (на `deque`).
* Проверка палиндрома (на `deque`).
* Построить графики зависимости времени выполнения от количества элементов.

Оформить отчёт и код согласно PEP8, использовать git flow.

---

## Методика эксперимента

### Замеры

Использован модуль `timeit`.
Каждое измерение усреднено по нескольким прогонам.
Количество операций: от 100 до 1900 (с шагом 200).

### Тестируемые операции

* `list.insert(0, x)` (`O(n)`) vs `LinkedList.insert_at_start` (`O(1)`)
* `list.append` (амортизированное `O(1)`) vs `LinkedList.insert_at_end` (`O(1)` с `tail`)
* `list.pop(0)` (`O(n)`) vs `deque.popleft` (`O(1)`)

### Характеристики ПК

* **CPU:** Intel Core i7-8700 @ 3.6GHz
* **RAM:** 32 GB DDR4
* **OS:** Windows 11
* **Python:** 3.11.9

---

## Разбор сложности

1.  **`insert_at_start` → `O(1)`**

    В односвязном списке у нас есть ссылка `head` (первый элемент). Чтобы вставить новый элемент в начало, достаточно:
    * Создать новый узел.
    * Указать, что его `next` → старый `head`.
    * Переназначить `head` на новый узел.

    Количество шагов не зависит от размера списка. Поэтому сложность = `O(1)` (константная).

2.  **`insert_at_end` → `O(n)` или `O(1)`**

    * **Если в списке нет указателя на `tail`:**
        Чтобы найти конец, нужно пройти по всем узлам от `head` до последнего. Это требует n шагов. Сложность = `O(n)`.

    * **Если есть ссылка `tail` (последний элемент хранится явно):**
        Достаточно 1 операции: привязать `tail.next` к новому узлу и обновить `tail` → новый узел. Не нужно обходить весь список. Сложность = `O(1)`.

3.  **`delete_from_start` → `O(1)`**

    Удаление первого элемента делается очень просто: `head = head.next`. Независимо от длины списка, это всегда одна операция. Сложность = `O(1)`.

4.  **`traversal` (обход списка) → `O(n)`**

    Чтобы пройти по всем элементам и что-то с ними сделать (например, напечатать), нужно идти от `head` и двигаться через `.next` до конца. Количество шагов = числу элементов `n`. Сложность = `O(n)`.

---

## Результаты

### Вставка в начало (`list.insert(0)` vs `LinkedList.insert_at_start`)

| Количество | list (мс) | linked (мс) |
| :--- | :--- | :--- |
| 100 | 0.0079 | 0.0240 |
| 700 | 0.1399 | 0.1928 |
| 1300 | 0.2875 | 0.3264 |
| 1900 | 0.6053 | 0.4719 |

`list` показывает линейный рост (`O(n)`). `LinkedList` держится почти константным временем (`O(1)`), хотя из-за накладных расходов Python он медленнее на малых размерах.

### Вставка в конец (`list.append` vs `LinkedList.insert_at_end`)

| Количество | list.append (мс) | linked.insert\_end (мс) |
| :--- | :--- | :--- |
| 100 | 0.0036 | 0.0251 |
| 700 | 0.0283 | 0.1708 |
| 1500 | 0.0839 | 0.4455 |
| 1900 | 0.0570 | 0.5615 |

Формально обе операции `O(1)`. На практике встроенный список быстрее, т.к. оптимизирован на уровне C.

### Очередь (`list.pop(0)` vs `deque.popleft`)

| Количество | list.pop(0) (мс) | deque.popleft (мс) |
| :--- | :--- | :--- |
| 100 | 0.0088 | 0.0046 |
| 700 | 0.0575 | 0.0270 |
| 1300 | 0.1591 | 0.0779 |
| 1900 | 0.2413 | 0.0787 |

`list.pop(0)` растёт линейно (`O(n)`). `deque.popleft()` остаётся почти константным (`O(1)`).

---

## Анализ графиков

1.  **Вставка в начало (`list.insert(0, x)` vs `LinkedList.insert_at_start`)**

    На графике видно, что у `list` время растёт почти линейно: чем больше элементов, тем медленнее становится операция. Это соответствует теоретической сложности `O(n)`, потому что при вставке Python двигает все элементы массива вправо.

    У `LinkedList` рост времени почти незаметен: кривая остаётся почти плоской. Это соответствует `O(1)`, так как нужно просто переназначить `head`.

    Интересный момент: на малых размерах `list` иногда работает быстрее, чем `LinkedList`. Это связано с тем, что встроенный список реализован на C и очень сильно оптимизирован, тогда как наш связанный список написан на Python и имеет дополнительные накладные расходы. Но при больших размерах преимущество `LinkedList` становится очевидным.

2.  **Вставка в конец (`list.append(x)` vs `LinkedList.insert_at_end`)**

    Теоретически обе операции должны быть `O(1)`:
    * `append` добавляет элемент в конец массива (амортизированно `O(1)`).
    * `insert_at_end` добавляет элемент после `tail` (`O(1)`).

    На графике видно, что `list.append` стабильно быстрее, чем наш `LinkedList.insert_at_end`. Это объясняется тем, что встроенный список в Python реализован на низком уровне (C, с выделением памяти блоками), а наш `LinkedList` требует создания узла и работы с объектами Python. То есть теория совпадает (оба `O(1)`), но практика показывает, что для конца списка `list` предпочтительнее.

3.  **Очередь (`list.pop(0)` vs `deque.popleft`)**

    Здесь различие самое наглядное:
    * У `list.pop(0)` график идёт резко вверх → это `O(n)`, так как при удалении первого элемента Python двигает все оставшиеся элементы влево.
    * У `deque.popleft` график почти плоский → это `O(1)`, так как `deque` хранит ссылки на начало и конец и умеет быстро удалять с обоих концов.

    Разница растёт с увеличением числа операций: чем больше элементов, тем хуже ведёт себя `list.pop(0)` и тем больше становится отставание от `deque`.

![Графики](insert_end_comparison.png)
![Графики](insertion_comparison.png)
![Графики](queue_comparison.png)